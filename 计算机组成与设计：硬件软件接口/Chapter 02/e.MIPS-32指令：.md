#### 1.MIPS-32指令格式：
- MIPS-32中的指令为定长指令，也就是对于任何一种确定指令，其指令的长度都为32位，也就是一个字，处理器一次正好能够处理一个指令。
- MIPS-32中一共有三种指令格式：R型，I型，J型。
###### a.R型(寄存器类型)：
- R型指令的字段：
![](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/R型指令.png)
- 对于R类型指令，源操作数和目标操作数必须都是寄存器。
###### b.I型(立即数类型)：
- I型指令的字段：
![](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/I型指令.png)
###### c.J型(跳转类型)：
- J型指令的字段：
![](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/J型指令.png)
#### 2.运算指令：
###### add：
- ``add $t0 , $t1 , $t2``表示把寄存器t1和t2的值相加之后存入寄存器t0中。
- 该指令属于R类型指令。
###### sub：
- ``sub $t0 , $t1 , $t2``表示用寄存器t1的值减去寄存器t2的值，结果存入寄存器t0中。
- 该指令属于R类型指令。
###### addi：
- ``addi $t0 , $t1 , 0x2``表示把2这个立即数和寄存器t1中的值相加，存入寄存器t0中。
- 该指令属于I类型指令。
- 汇编指令中的立即数是不占用内存空间的。
- 一些注意事项：
	- 由于addi指令是i型指令，因此立即数的大小只有16位。
	- MIPS-32规定，这个立即数是有符号数，可正可负，当立即数为负数的时候，存储的编码为补码。
	- 因此该立即数的范围是-32768 ~ 32767。
###### and:
- ``and $t0 , $t1 , $t2``表示把寄存器t1的值和t2的值进行按位与操作，结果存入t0中。
- 该指令属于R类型指令。
###### or：
- ``or $t0 , $t1 , $t2``表示把寄存器t1的值和t2的值进行按位或操作，结果存入t0中。
- 该指令属于R类型指令。
###### nor或非：
- ``nor $t0 , $t1 , $t2``表示把寄存器t1的值和寄存器t2的值进行按位或非操作。
- 该指令属于R类型指令。
- 对于MIPS-32来讲，没有非(按位取反)指令。
- 我们知道，一个数与0做或运算的结果是这个数本身，那么再取非就是这个数按位取反的结果。
- 因此``nor $t0 , $t1 , $zero``这一条指令就实现了对寄存器t1按位取反，并将结果存入t0中。
###### andi：
- ``andi $t0 , $t1 , 0x2``表示把寄存器t1的值和立即数2进行按位与操作，结果存入t0中。
- 该指令为I型指令，因此有16bit用来存储立即数。
- 注意：MIPS-32要求这个立即数是无符号数，因此为正，取值范围是：0 ~ 65535。
###### ori：
- ``ori $t0 , $t1 , 0x2``表示把寄存器t1的值和立即数2进行按位或操作，结果存入t0中。
- 该指令为I型指令，因此有16bit用来存储立即数。
- 注意：MIPS-32要求这个立即数是无符号数，因此为正，取值范围是：0 ~ 65535。
###### sll：
- ``sll $t0 , $t1 , 0x3``表示把寄存器t1中的值左移3位，并把结果存放到寄存器t0中。
- 移位后右侧补0。
- 该指令为R型指令。
- 注意：
	- 对于移位运算符来讲，指令段rs(也就是第一个源操作数的位置)恒为0。
	- shamt段存储的是移位的个数，shamt段有5bit，因此移位空间是0 ~ 31。
- 一个数在左移的时候，如果没有位数丢失，那么每一次左移都能相当于乘2。对于比较小的数，我们一般使用左移来乘2。
###### srl：
- ``srl $t0 , $t1 , 0x3``表示把寄存器t1中的数据右移3位，并把结果保存在寄存器t0中。
- 移位后左侧补0。
- 该指令为R型指令。
- 注意：
	- 对于移位运算符来讲，指令段rs(也就是第一个源操作数的位置)恒为0。
	- shamt段存储的是移位的个数，shamt段有5bit，因此移位空间是0 ~ 31。
#### 3.数据传输指令：
- 数据传输指令用于数据在寄存器和内存之间进行交换。
###### lw(load word):
- 取字指令，每次从内存中取出一个字(4byte)的数据放入寄存器中。
- ``lw $t0 , 20($s0)``该指令从寄存器s0所存的地址上偏移20个字节，也就是从s0所存地址开始算起的第5个字上取出数据(4byte)，放入寄存器t0中。
- 偏移量以字节为单位，但是由于是取字，因此偏移量应该是4的整数倍。
- 该指令是I型指令。
- 指令段中的rs对应寄存器s0的编号；rt对应寄存器t0的编号，此时rt表示目标寄存器编号。
###### sw(store word)：
- 存字指令，把寄存器中的数据存入内存中。
- ``sw $t0 , 20($s0)``该指令把寄存器t0中的值，存入以寄存器s0所存的地址为基地址，偏移20个字节的位置。
- 偏移量以字节为单位，但是由于是存字，因此偏移量应该是4的整数倍。
- 该指令是I型指令。
- 指令段中的rs对应寄存器t0的编号；rt对应寄存器s0的编号，此时rt表示目标寄存器编号。注意与lw的指令段区分。
##### a.符号扩展：
###### lh(load half)：
- 为了方便，我们这里只说明取半字、无符号取半字、存半字。
- 我们要注意，这里的半字指的是一个字中的低半字，对于取字节来讲，取的也是最小端的字节，而不是说对应哪个字节就取哪个字节。
- ``lh $t0 , 0($s0)``这条指令表示在寄存器s0所存的地址上，取这个字的低半字，放入寄存器$t0中。
- 放入寄存器的时候按照有符号的形式放入，如果低半字的最高位是1，那么认为是负数，则放入寄存器的时候，寄存器的高16位被扩展成1，相反被扩展成0。
- 该指令属于I型指令。
###### lhu(load half unsigned)：
- 无符号取半字``lhu $t0 , 0($s0)``这条指令表示在寄存器s0所在的地址上，取这个字的低半字，以无符号的形式放入寄存器$t0中，也就是寄存器的高16位被扩展成0。
- 该指令属于I型指令。
###### sh(store half)：
- ``sh $t0 , 0($s0)``这条指令表示把寄存器t0中的低半字，存入寄存器s0所存地址中。
- 注意，该指令默认以无符号的形式存储，存入内存目标字的低半字，高半字全部为0。
##### b.装载32位立即数：
- 使用addi指令处理的立即数范围是：-32768 ~ 32767，因此将32位立即数存入寄存器中还需要其他指令。
###### lui：
- ``lui $t0 , 0xffff``表示将立即数0xffff存入寄存器t0的高16位上，同时把寄存器t0的底16位初始化为0。
- 该指令为I型指令，因此立即数的范围是0 ~ 0xffff。
###### ori：
- ``ori $t0 , $t0 , 0xffff``表示将立即数0xffff与寄存器t0的值进行或运算，由于这个立即数最大为0xffff，并且寄存器t0的底16位全部为0，因此就相当于在没有影响t0高16位的情况下，把0xffff放到了寄存器t0的低16位上。
###### 装载成功：
- 这两个指令同时使用，就把0xffffffff这个32位立即数存储到了寄存器t0中。
#### 4.跳转指令：
##### a.标签：
- 在汇编语言中，标签就相是过程名，一个标签代表着一个地址，使用跳转指令跳转到标签上就能够从标签处开始继续执行指令。
###### beq(branch if equal)：
- 相等则分支，``beq $t0 , $t1 , Branch``如果寄存器t0和寄存器t1的值相等，则程序跳转到Branch这个标签处，从Branch开始继续执行。
- 该指令是I型指令。
###### bne(branch if not equal)：
- 不等则分支，``bne $t0 , $t1 , Branch``如果寄存器t0和寄存器t1的值不等，则程序跳转到Branch这个标签处，从Branch开始继续执行。
- 该指令是I型执行。
###### slt(set on less than)：
- 我们先来了解一下什么是置位和复位，在计算机中，我们把一个信号设置为1就叫做置位，把一个信号设置为0就叫做复位。
- 小于则置位，``slt $t0 , $t1 , $t2``如果寄存器t1小于寄存器t2，那么寄存器t0被置位“1”，否则被复位“0”。
- 该指令为R类型指令。
- 这里我们要注意，slt指令把两个源操作寄存器中的值当成有符号数进行处理。
###### slti(立即数版本)：
- 和slt指令的用法相同，是I类型指令。
- 由于立即数被当做有符号数，因此立即数的范围是-32768 ~ 32767。
###### sltu(unsigned版本)：
- 和slt指令的用法相同，是R型指令。
- 该指令把源操作寄存器中的数当成无符号类型。
###### j(jump)：
- 无条件跳转指令，``j Branch``表示直接跳到Branch标签处。
- 该指令为J型指令。
##### b.if-else语句：
- 通过上面四类指令的组合，我们可以完成所有if-lse语句的翻译。
###### 1.判断条件为 “ == ”的if-else语句：
```C
if (i == j)
	f = g + h;
else
	f = g - h;
//这里，我们把i，j的值放入寄存器：$s0 , $1
//f，g，h的值放入寄存器：$t0 , $t1 , $t2
//我们先来观察一下这个if-else，当i == g的时候，则执行if语句，否则执行else语句，因此else语句相当于分支。
//因此，我们的分支语句应该用bnf，branch if not equal。
//MIPS汇编：

bnf $s1 , $s2 , Else #如果i不等于j，则切换到分支Else;
add $t0 , $t1 , $t2 #如果i等于j，则执行加法;
j Exit #这里我们为了避免顺序执行Else分支，因此使用一个jump跳转到Exit，Exit标签不需要内容;
Else: 
sub $t0 , $t1 , $t2 #Else标签，执行减法操作;
Exit：#退出标签。
```
###### 2.判断条件为 “ != ”的if-else语句：
```C
if (i != j)
	f = g + h;
else
	f = g - h;
//由于相等条件是跳转分支，因此使用beq
//MIPS汇编:
beq $s0 , $s1 , Else 
add $t0 , $t1 , $t2 
j Exit 
Else: 
sub $t0 , $t1 , $t2 
Exit: 
```
###### 3.判断条件为 “ < ”的if-else语句：
```C
if (i < j)
	f = g + h;
else
	f = g - h;
//这里我们需要用到小于则置位。
//这里的分支条件是不小于，也就是复位跳转。
//MIPS汇编：

slt $t3 , $s0 , $s1 
#如果i < j，则t3 = 1，因此下面的跳转不成立，顺序执行，如果条件不成立，则t3 = 0，下面的跳转成立，接下来会执行Else分支。
beq $t3 , $zero , Else 
add $t0 , $t1 , $t2 
j Exit 
#为了避免if-else全都执行，使用jump跳转指令。
Else: 
sub $t0 , $t1 , $t2 
Exit: 
```
- 判断>条件的时候只需要把beq分支跳转改成bne分支跳转即可。
###### 4.判断条件为 “ < ”的if-else语句：
```C
if (i <= j)
	f = g + h;
else
	f = g - h;
//这里我们需要使用小于则置位。
//注意，相等的条件同样需要判断。
//MIPS汇编：

slt $t3 , $s0 , $s1 
#如果i < j,则t3 = 1，并且下面的跳转不成立，因此执行If分支；如果t3 = 0，则跳转到Else，注意，t3等于0的时候，可能是由i == j引起的，因此我们还需要在Else分支中检测一次，使用一个相等则跳转指令。
beq $t3 , $zero , Else 
If: 
add $t0 , $t1 , $t2 
j Exit 
#为了避免if-else全都执行，使用jump跳转指令。
Else: 
beq $s0 , $s1 , If 
sub $t0 , $t1 , $t2 
Exit: 
```
- 判断>=条件的时候只需要把第一个beq分支跳转改成bne分支跳转即可。
##### c.数组下标越界检验：
- 可以使用sltu对数组下标是否越界进行检验。
- 检验思想如下：
	- 假设数组下标的循环变量是t0，数组大小为t1。
	- 越界的两种情况：1.数组下标循环变量t0小于0，第二种情况，数组下标循环变量t0大于t1。
	- 对于两个寄存器中的数据，如果t0是负数，那么其最高位一定是1，此时可以利用sltu来判断，t0会恒大于t1的值。
	- 如果两个寄存器中的数都为正数，那么当t0大于t1的时候也是越界。
- 因此我们使用一条sltu加一条跳转指令就可以完成该操作。
```C
//MIPS汇编：
sltu $t2 , $t1 , $t0
#如果越界，那么t1中的值就会小于t0中的值，此时对t2进行置位操作，不跳转；如果没越界，那么t2为0，此时下一条条件分支语句会进行跳转。
beq $t2 , $zero , IndexOutOfBounds
#跳转到标签IndexOutOfBounds处，该标签处可能会提供越界提示操作。
```
##### d.过程调用中的跳转和链接指令：
- 对于C语言中的函数调用，调用的时候主函数把控制权交给被调函数，调用结束后程序再回到主函数中执行下一条语句。
- 在汇编语言中，使用跳转和链接指令来执行过程。
###### jal：
- ``jal Branch``表示把下一条指令的地址存入寄存器$ra，然后跳转到标签Branch的位置开始执行该过程。
###### jr：
- ``jr $ra``表示直接跳转到寄存器ra中存储的地址的位置。
- 因此我们可以发现，将jal和jr两条指令连用就实现了过程调用。
##### e.叶过程的执行：
- 在汇编语言中，调用一个过程就相当于执行分支跳转。
- 在C语言中，需要向函数传递参数，因此在汇编中也同样存在这个问题。
- $a0 ~ $a3这四个寄存器用来存放向过程传递的参数， $v0 ~ $v1这两个寄存器存放过程的返回值。
- 下面用MIPS汇编实现一个数组清零操作：
```C
void clear(int a[] , int size)
{
	for (int i = 0 ; i < size ; i++)
		a[i] = 0;
	return;
}

//假设数组a的基地址存在寄存器a0中，参数size存在寄存器a1中。
//将变量i存在寄存器t0中。

//MIPS汇编代码：
move $t0 , $zero
#首先把变量i初始化为0，使用一条伪指令move;
Loop:#开始进入循环;
slt $t1 , $t0 , $a1 
#首先比较变量i和数组大小size的值，小于则满足循环，置位并且执行下面的这条分支语句；否则说明不进入循环，也就是跳转会主程序的下一条指令处，通过读取jr指令实现。
bne $t1 , $zero , Clear 
jr $ra #退出循环的话那么就返回主程序的下一条指令。
Clear: #开始进入数组清零过程;
sll $t2 , $t0 , 0x2 
#首先把i的值左移两位，这样相当于对i乘4(因为int数组每个元素占一个字的大小，所以每次移动4字节寻址)，并且把这个临时值存在t2中。
add $t3 , $t2 , $a0 
#把偏移量t2和基地址a0相加，获取a[i]的地址。
sw $zero , 0($t3)
#将a[i]清零。
addi $t0 , $t0 , 0x1 
#这里对变量i进行自增加操作
j Loop #继续跳转回标签Loop，执行下一次循环。
```
##### f.嵌套过程的执行：
- 由于嵌套调用过程，因此需要对寄存器$ra进行换出操作。
- 下面用MIPS实现一个求平方和操作：
```C
int sum_of_squares(int a[] , int size)
{
	int sum = 0;
	for (int i = 0 ; i < size ; i++)
		sum += square(a[i]);
	return sum;
}
int square(int a)
{
	return a * a;
}


//假设数组a的基地址存在寄存器a0中，参数size存在寄存器a1中,向square函数中传递的参数放入寄存器a3中。
//将变量sum存在寄存器t0中，将变量i存在寄存器t1中。

//MIPS汇编：
move $t0 , $zero
move $t1 , $zero
#上述两条指令将变量sum和i进行初始化0操作。
Loop:
slt $t2 , $t1 , $a1
#如果i的值小于size的值，则置位，并且执行循环，否则返回sum的值，并且返回到主程序的下一条指令。
bne $t2 , $zero , Sum
#t2不等于，则执行循环中的Sum操作。
move $v0 , $t0
addi $sp , $sp , 0x4
lw $ra , 0($sp)
jr $ra
#上面四条指令完成的是跳出循环之后的操作：
#首先，将返回值sum放入返回值寄存器v0；
#其次，由于调用过其他函数，因此ra寄存器中的内容进行过换出，此时在调用sum_of_squares这个过程中创建的栈中，只有一个主程序的地址了，因此将栈指针上移一个字，然后把这个地址取到ra中。
#最后，使用jr跳转回主程序的下一条指令。
Sum:
sll $t3 , $t1 , 0x2
add $t4 , $t3 , $a0
#上面两条语句获得了a[i]的地址，存在t4中。
lw $a3 , 0($t4)
addi $t1 , $t1 , 0x1
#上面两条语句将a[i]读了出来，并且写入寄存器a3中，作为参数。
#变量i的值自增加。
addi $sp , $sp , -0x4
sw $ra , 4($sp)
//上述两条指令完成了一个换出寄存器的操作，由于接下来ra的值要被使用，因此要把此时ra的值存入栈中。
jal Square
#跳转并链接，此时ra存放的是下面add这条指令的地址。
add $t0 , $t0 , $v0
j Loop #Sum过程执行完毕，此时跳回Loop，再次执行循环。

Square:
mult $v0 , $a3 , $a3
jr $ra
```
##### g.伪指令：
- MIPS-32提供了很多伪指令，处理器只能读懂普通指令，不能读懂伪指令。
- 伪指令可以减少汇编代码，在写汇编程序的时候推荐使用，伪指令本质上就是一些普通指令的组合。
- 汇编器能够读懂伪指令，将伪指令转换为普通指令，然后交给处理器执行。
###### 常见伪指令：
- ``move $t0 , $t1``把寄存器t1的值复制到寄存器t0中。
- ``mult $t0 , $t1 , $t2``把寄存器t1的值和寄存器t2的值相乘后放入寄存器t0中。