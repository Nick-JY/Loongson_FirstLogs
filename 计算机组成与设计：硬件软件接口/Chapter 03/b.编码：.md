## 编码：
#### 1.有符号数：
- 我们默认后面的示例在位宽为8的数据位中进行讨论。
- 有符号数指的就是分正负号的数据。
- 在计算机的发展史中，一共使用过三种类型的编码来表示有符号数：原码——反码——补码，最终在19世纪60年代左右补码成为了有符号数的历史选择。
##### a.原码：
- 我们把最高位当做符号位，剩下的七位用作数据位。
- 如果符号位为0，那么数据表示正数，如果符号位为1，数据表示负数。
- 表示范围：
	- 正数：0000 0000 ~ 0111 1111(0 ~ 127)
	- 负数：1111 1111 ~ 1000 0000(-127 ~ -0)
- 很显然，我们发现使用原码来表示的话会有两个0，一个是+0，一个是-0，由于0的不唯一性，我们抛弃了原码。
##### b.反码：
- 同样，我们把最高位当做符号位，剩下的七位表示数据位，当符号位为0的时候表示正数，为1的时候表示负数。
- 和原码的区别：
	- 在负数的表示上有区别，对于负数，我们首先要知道这个负数的相反数的编码，也就是对应的正数的编码，然后每一位全部取反(包括符号位在内，因为取反之后符号位正好从0变为1)。
- 表示范围：
	- 正数：0000 0000 ~ 0111 1111(0 ~ 127)
	- 负数：1000 0000 ~ 1111 1111(-127 ~ -0)
- 很显然，用反码来表示和用补码来表示的问题一样，都会有0不唯一这一个问题，因此我们抛弃了反码。
##### c.补码：
- 既然上面两种编码都有0不唯一的问题，那么我们是不是可以考虑把负数表示的范围更改一下，从-127 ~ -0更改为-128 ~ -1，这样不就可以解决0不唯一的问题了吗。
###### 从原码入手：
- 我们首先考虑从原码入手，把1111 1111 ~ 1000 0000映射为：-128 ~ -1，我们现在这样看着好像很合理，但实际上我们做一个运算：-1 + 127 = 1000 0000 + 0111 1111 = 1111 1111，正常结果应该是126，但运算结果确实-127，因此这种方法我们抛弃。
###### 从反码入手：
- 我们再考虑从反码入手，把1000 0000 ~ 1111 1111映射为：-128 ~ -1，现在我们进行运算，127 + (-1) = 0111 1111 + 1111 1111 = 1 0111 1110 由于只有8位，因此最高位是要被截掉的，因此结果为：0111 1110，表示126，其他运算结果也都合理。
- 这样我们就得到了补码。
###### 补码：
- 通过上面的分析我们知道，补码与其他两种编码的区别在于只有负数的表示不同。
- 补码的负数表示：
	- 首先我们要知道这个负数的相反数的补码(该补码与原码和反码相同)，我们把这个原码取反之后在加1，就表示出了这个负数的补码。
- 表示范围：
	- 正数：0000 0000 ~ 0111 1111(0 ~ 127)
	- 负数：1000 0000 ~ 1111 1111(-128 ~ -1)
###### 补码的相反数准则：
- 我们可以发现，对于互为相反数的一组数，他们的补码相加同样为0(有一些是得到九位数1 0000 0000，但硬件位是固定的，因此相当于0000 0000)。
- 因此，我们可以认为，二进制补码的相反数就是其取反再加1。
###### 补码使用的优点：
- 使用补码，我们可以把减法直接当成加法来操作，这样就省去了构建减法器的工作。
#### 2.无符号数：
- 无符号数是非负数，因此我们在表示无符号数的时候，不需要符号位，直接使用其二进制编码对无符号数进行编码即可。
- 八位的无符号数表示范围：
	- 0000 0000 ~ 1111 1111(0 ~ 255)
#### 3.溢出：
- 溢出有两种情况：
	- 赋值溢出，把16位数据赋值到一个8位字段中。
	- 运算溢出，对于运算溢出，我们只考虑有符号数的运算溢出，无符号数经常用来表示内存地址，因此无符号数的溢出可以被忽略。
- 四种加减运算的溢出：
	- 溢出产生的原因：用来表示数据的位数有限，而不像我们的现实生活中的数据可以无穷大。
	- 两个正数相加结果为负数，此时发生溢出。
	- 两个负数相加结果为正数，此时发生溢出。
	- 上面上面这两种叫做上溢，也就是在相加的过程中，占用了符号位。

	- 一个正数减去一个负数的结果为负，此时发生溢出。
	- 一个负数减去一个正数的结果为正，此时发生溢出。
	- 上面这两种情况叫做下溢，也就是在做减法的过程中，不够减，借用符号位造成了溢出。
##### 对溢出进行处理：
- 操作有符号数的时候，如果在运算的时候发生了溢出，我们要对溢出做出处理。
- add，addi，sub这三条指令是对有符号数进行运算的，如果发生溢出，这三条指令会产生异常。
##### 异常：
- 异常也叫中断，异常是打断处理器正常进程的系统调用，注意异常是操作系统的行为。
- 产生溢出的这条指令地址会保存在一个名为EPC的寄存器中(EPC是异常程序计数器，不是通用寄存器)，然后计算机会跳转到一个预先设置好的地址去执行相应的异常处理程序，执行完之后返回到原来的程序中继续执行(通过寄存器跳转指令跳转到原程序中，但是由于EPC不是通用寄存器，因此我们需要使用一个名为mfc0的指令将EPC中的地址传到通用寄存器中)。
