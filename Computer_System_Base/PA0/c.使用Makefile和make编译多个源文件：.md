## Makefile的初步入门：

### 1.为什么使用make来编译工程：

- 通常，我们的project由三部分组成：
  - 头文件.h
  - main.c
  - 模块文件.c

- 我们通常把函数的定义，全局变量的定义，宏的定义写进头文件，main.c文件只含有一个主函数main，模块文件使我们所使用的函数的定义文件。
- 如果project很小，比如模块文件只有``file_1.c file_2.c``这两个，那么我们使用一条命令很简单的就编译出了可执行文件：
  - ``gcc main.c file_1.c file_2.c``
- 可是，一般的project都是由很多文件组成的，并且很多文件之间会形成父子关系，因此如果我们单纯的使用``gcc``这类编译工具进行编译的时候，很可能漏掉文件，如果修改其中的某个文件的话，整个project要全部重新编译，这会花费太多时间。

#### 2.Makefile的编写：

#####   a.makefile与Makefile：

- 我们可能会在目录中看到``makefile``和``Makefile``，当我们执行make命令的时候，会首先检索有没有``makefile``这个文件，并且优先执行``makefile``里面的内容。
- 程序员在写代码的时候，会把优先级交给用户，因此程序员编写的代码默认都是编写``Makefile``文件。

#####   b.Makefile的编写：

- 首先是宏的定义:
  - 这里宏的定义指的是``文件名称``、``编辑器名称``、``命令选项``。
- 其次是文件关系生命：
  - 我们举一个简单的例子:``main.c file_1.c file_2.c``
    - 我们最终的目标文件是：``final``
    - 这个``final``文件是由``main.o file_1.o file_2.o``通过编译器编译而来。
    - 而``main.o``是``main.c``通过汇编器而来；``file_1.o``是``file_1.c``通过汇编器而来......
    - 注：``.o``文件是汇编文件。
    - 因此上诉的例子需要两个生成过程。
  - 具体代码如下：

```makefile
OBJ=main.o file_1,o file_2.o"OBJ一般是可执行文件所需要的.o文件。
CC=gcc"CC表示编译过程中使用的编译器。
OPTION+=-g -o"表示编译器的编译选项，对于gcc来讲，-o一定要累加写在最后，这样OPTION后面可以直接加生成文件名，-g表示显示编译信息。
RM=rm -rf"表示删除指令宏。

"我们在使用宏的时候，要有$()标志这是一个宏。
final:$(OBJ)"final表示要生成的文件名，冒号后面表示生成该文件所需要的依赖文件。
	$(CC) $^ $(OPTION) $@"^指代的是OBJ中的内容，也就是上面冒号后面的内容，@指代的是final。
"我们一般把编译的最终阶段写在最开始，意味着编译树的根节点。

%.o:%.c"这里我们采用泛式书写，%指代任何。其中，%.o表示任何.o文件，%.c表示与之同名的任何.c文件。
	$(CC) $^ -c $(OPTION) $@
"上面这一部分会将当前目录的所有.c文件编译成.o文件，其中-c表示将.c文件编译成.o文件。


clean:
	$(RM) *.o 
"clean是makefile中的清理选项，这里我们编写的是清理掉当前目录的所有.o文件，执行make clean即可。
```

